#!/usr/bin/env python
from __future__ import print_function

import sys
import os
import time
import json
import requests
from base64 import b64encode
from random import randint
import unicodedata

auth = b64encode(b"beach:surf")
headers = {'content-type': 'text/plain;',"Authorization":"Basic %s" % auth}
url = 'http://127.0.0.1:7777'
id = 0

def dot():
	sys.stdout.write('.')
	sys.stdout.flush()

def normalize(value):
	str = "%.9f" % value
	return float(str)

def send(data,display=False):
	global id
	data["id"] = id
	id += 1
	if display:
		print(data)
	response = requests.post(url,data=json.dumps(data),headers=headers)
	if response.status_code != 200:
		raise Exception('HTTP Error code: %s' % response.status_code)
	if response.json()["result"] == None:
		raise Exception('Command error: %s(%s)' % response.json()["error"]["message"] %  response.json()["error"]["code"])
	return response.json()["result"]


def blockCount(): 
	res = send({"method":"getblockcount","params":[]}) 
	return int(res)

def blockhash(index):
	res =  send({"method":"getblockhash","params":[index]}) 
	return res

def block(hash):
	res =  send({"method":"getblock","params":[hash]}) 
	return res

def txHasJS(hash):
	res =  send({"method":"getrawtransaction","params":[hash,1]})
	return len(res["vjoinsplit"]) > 0

def getAllJS():
	res =  send({"method":"dtg2","params":[]})
	return res

def rawTx(hash):
	res = send({"method":"getrawtransaction","params":[hash,1]})
	del res["hex"]
	return res

def showTx(i,tx):
	print("TX: %s | hash: %s" % (i,tx))
	print(json.dumps(rawTx(tx),indent=4,sort_keys=True))

def showTxs(bloc):
	txs = bloc["tx"]
	for i in range(0,len(txs)):
		showTX(i,txs[i])

def getBalance(addr):
	res = send({"method":"z_getbalance","params":[addr]}) 
	return float(res)


def newTAddress():
	res = send({"method":"getnewaddress","params":[]}) 
	return res

def newZAddress():
	res = send({"method":"z_getnewaddress","params":[]}) 
	return res

def getOpidResult(opid):
	res = send({"method":"z_getoperationstatus","params":[[opid]]}) 
	return res

def sendFrom(amount,toAddress):
	res = send({"method":"sendfrom","params":["",toAddress,amount]}) 
	return res

coinbases = { }

#if  len(sys.argv) < 2 or len(sys.argv) > 4:
#    print ('usage: ', os.path.basename(os.path.normpath(sys.argv[0])), ' amount [number of txs [number of addresses]]')
#    sys.exit()





for index in range(1,blockCount()): 
	hash = blockhash(index).encode("ascii")
	bloc = block(hash)
#	print(json.dumps(bloc,indent=4,sort_keys=True))
	tx = rawTx(bloc["tx"][0].encode("ascii"))
#	print(json.dumps(tx,indent=4,sort_keys=True))
	addresses = tx["vout"][0]["scriptPubKey"]["addresses"]
	for addr in addresses:
		if addr in coinbases:
			coinbases[addr] += 1
		else:
			coinbases[addr] = 1

print("%d coinbase addresses" % len(coinbases))
for k,v in coinbases.iteritems():
	balance = getBalance(k)
	if balance > 0.0:
		print("%s : %d : %.8f" %(k,v,balance))
 

			
'''

	if len(bloc["tx"]) >= minCount:
		print("Block: %s | Count: %s" % (start,len(bloc["tx"])))
		number -= 1
	start -= 1

amount = float(sys.argv[1])

txs = 100
if len(sys.argv) > 2:
	txs = int(sys.argv[2])
	
addCount = 10
if len(sys.argv) > 3:
	addCount = int(sys.argv[3])

addList = [ ]
for i in range(0,addCount):
	add = newTAddress().encode("ascii")
	addList.append(add)
	print(add)

for i in range(0,txs):
	toAddress = addList[randint(1,addCount)-1]
	tx = sendFrom(amount*1.0,toAddress)
	print("%s : %s" % (toAddress,tx))
'''







